<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Win % by Player</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Win % by Player</h1>
  <canvas id="winChart" width="400" height="200"></canvas>

  <script>
    class RandomPlayer {
      name;
      
      constructor(name) {
        this.name = name;
      }
      
      hit(gameState) {
        if (gameState.playerStates.get(this).cards.some(c => c === 'SecondChance'))
          return true;
        else
          return Math.random() < 0.75;
      }
      
      freeze(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this);
        if (otherPlayers.length == 0)
          return this;
        else
          return otherPlayers.reduce((max, current) => (max === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) > gameState.playerStates.get(max).score() + gameState.playerScores.get(max) ? current : max), null);
      }
      
      giveSecondChance(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this && !gameState.playerStates.get(p).cards.some(c => c === 'SecondChance'));
        if (otherPlayers.length > 0) {
          return otherPlayers.reduce((min, current) => (min === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) < gameState.playerStates.get(min).score() + gameState.playerScores.get(min) ? current : min), null);
        } else {
          return null;
        }
      }
      
      flip3(gameState) {
        const players = gameState.playersInGame();
        return players[Math.floor(Math.random() * players.length)];
      }
    }

    class ExpectedValuePlayer {
      name;
      
      constructor(name) {
        this.name = name;
      }
      
      hit(gameState) {
        // Want a lower bound. Use expected value; for freezes and second chances, technically nothing is gained or lost immediately, freeze can only give you 0, and second chances give you 0 or positive later.
        // However, for flip3, it's more complicated. A lower bound would be to calculate P(flip3) * (-currentScore). This assumes busting, which would be a lower bound on expectation (could get higher).
        // So, in summary...
        // P(flip3) * (onlyPlayerInRound ? -currentScore : 0)
        // + P(bust number) * (haveSecondChance ? 0 : -currentScore)
        // + P(bonuses or non-bust numbers)
        
        // Of course, the deck has the exact ordering--but using that is cheating.
        const currentRoundScore = gameState.playerStates.get(this).score();
        const cardCounts = new Map();
        gameState.deck.forEach(c => cardCounts.set(c, (cardCounts.get(c) || 0) + 1));
        const cardsLeft = gameState.deck.length;
        const numberCardsCausingBust = gameState.playerStates.get(this).cards.filter(c => ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'].some(n => n === c));
        const haveSecondChance = gameState.playerStates.get(this).cards.some(c => c === 'SecondChance');
        
        const flip3Contribution = -1 * currentRoundScore * (cardCounts.get('Flip3') || 0);
        const bustContribution = numberCardsCausingBust.map(card => cardCounts.get(card) || 0).reduce((partialSum, current) => partialSum + current, 0) * (haveSecondChance ? 0 : -1 * currentRoundScore);
        const nonBustContribution = [...cardCounts.keys()].filter(c => !numberCardsCausingBust.some(b => b === c)).map(c => {
          if (c === 'x2') {
            return currentRoundScore;
          } else if (c[0] === '+') {
            return parseInt(c.substring(1));
          } else if (['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'].some(numberedCard => numberedCard === c)) {
            return parseInt(c) * cardCounts.get(c);
          } else {
            return 0;
          }
        }).reduce((partialSum, current) => partialSum + current, 0);
        
        const lowerBoundExpectedValue = (nonBustContribution + bustContribution + flip3Contribution) / cardsLeft;
        
        return lowerBoundExpectedValue > 0;
      }
      
      freeze(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this);
        if (otherPlayers.length == 0)
          return this;
        else
          return otherPlayers.reduce((max, current) => (max === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) > gameState.playerStates.get(max).score() + gameState.playerScores.get(max) ? current : max), null);
      }
      
      giveSecondChance(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this && !gameState.playerStates.get(p).cards.some(c => c === 'SecondChance'));
        if (otherPlayers.length > 0) {
          return otherPlayers.reduce((min, current) => (min === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) < gameState.playerStates.get(min).score() + gameState.playerScores.get(min) ? current : min), null);
        } else {
          return null;
        }
      }
      
      flip3(gameState) {
        const players = gameState.playersInGame();
        return players[Math.floor(Math.random() * players.length)];
      }
    }
    
    class HumanApproximatedExpectedValuePlayer {
      name;
      
      constructor(name) {
        this.name = name;
      }
      
      hit(gameState) {
        const numberCardsCouldBust = ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
        
        const bustCards = gameState.playerStates.get(this).cards.filter(c => numberCardsCouldBust.some(n => n === c)).map(c => parseInt(c));
        
        const sumOfBustCards = bustCards.reduce((partialSum, term) => partialSum + term, 0);
        const bustApproximation = Math.floor(sumOfBustCards * sumOfBustCards / 10);
        
        const sumsNotContributingTo55 = bustCards.map(c => parseInt(c)).map(n => {
          if (n === 12) {
            return 14;
          } else if (n === 11) {
            return 12;
          } else if (n === 10) {
            return 10;
          } else if (n === 9) {
            return 8;
          } else if (n === 7) {
            return 4;
          } else if (n === 6) {
            return 3;
          } else if (n === 5) {
            return 2;
          } else if (n === 4) {
            return 1;
          } else if (n === 3) {
            return 1;
          } else {
            return 0;
          }
        }).reduce((partialSum, term) => partialSum + term, 0);
        return 55 - sumsNotContributingTo55 > bustApproximation;
      }
      
      freeze(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this);
        if (otherPlayers.length == 0)
          return this;
        else
          return otherPlayers.reduce((max, current) => (max === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) > gameState.playerStates.get(max).score() + gameState.playerScores.get(max) ? current : max), null);
      }
      
      giveSecondChance(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this && !gameState.playerStates.get(p).cards.some(c => c === 'SecondChance'));
        if (otherPlayers.length > 0) {
          return otherPlayers.reduce((min, current) => (min === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) < gameState.playerStates.get(min).score() + gameState.playerScores.get(min) ? current : min), null);
        } else {
          return null;
        }
      }
      
      flip3(gameState) {
        const players = gameState.playersInGame();
        return players[Math.floor(Math.random() * players.length)];
      }
    }
    
    class HitUpToN {
      name;
      hitCutoff;

      constructor(name, hitCutoff) {
        this.name = name;
        this.hitCutoff = hitCutoff;
      }
      
      hit(gameState) {
        if (gameState.playerStates.get(this).cards.some(c => c === 'SecondChance'))
          return true;
        else if (gameState.playerStates.get(this).cards.filter(c => ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'].some(n => c === n)).reduce((accumulated, current) => accumulated + current, 0) <= this.hitCutoff)
          return true;
        else
          return false;
      }
      
      freeze(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this);
        if (otherPlayers.length == 0)
          return this;
        else
          return otherPlayers.reduce((max, current) => (max === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) > gameState.playerStates.get(max).score() + gameState.playerScores.get(max) ? current : max), null);
      }
      
      giveSecondChance(gameState) {
        const otherPlayers = gameState.playersInGame().filter(p => p !== this && !gameState.playerStates.get(p).cards.some(c => c === 'SecondChance'));
        if (otherPlayers.length > 0) {
          return otherPlayers.reduce((min, current) => (min === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) < gameState.playerStates.get(min).score() + gameState.playerScores.get(min) ? current : min), null);
        } else {
          return null;
        }
      }
      
      flip3(gameState) {
        if (gameState.playerStates.get(this).cards.filter(c => ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']).length <= 1) {
          return this;
        } else {
          const otherPlayers = gameState.playersInGame().filter(p => p !== this);
          if (otherPlayers.length == 0) {
            return this;
          } else {
            return otherPlayers.reduce((max, current) => (max === null || gameState.playerStates.get(current).score() + gameState.playerScores.get(current) > gameState.playerStates.get(max).score() + gameState.playerScores.get(max) ? current : max), null);
          }
        }
      }
    }
    
    class PlayerState {
      busted;
      stayed;
      frozen;
      cards;
      
      constructor() {
        this.reset();
      }
      
      reset() {
        this.busted = false;
        this.stayed = false;
        this.frozen = false;
        this.cards = [];
      }
      
      score() {
        if (this.busted) {
          return 0;
        } else {
          // Add number cards.
          const x2 = this.cards.some(c => c === 'x2');
          const bonuses = this.cards.filter(c => c[0] === '+').map(c => parseInt(c.substring(1))).reduce((accumulator, current) => accumulator + current, 0);
          const numbers = this.cards.filter(c => ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'].some(numberCard => numberCard === c)).map(c => parseInt(c)).reduce((accumulator, current) => accumulator + current, 0);
          let score = numbers;
          if (x2) {
            score *= 2;
          }
          score += bonuses;
          
          return score;
        }
      }
      
      flippedSeven() {
        return this.cards.filter(playerCard => ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'].some(numberCard => numberCard === playerCard)).length === 7;
      }
    }
    
    class GameState {
      deck;
      playerStates;
      discarded;
      playerScores;

      constructor(players) {
        this.deck = GameState.createDeck();
        this.shuffleDeck();
        this.discarded = [];
        this.playerStates = new Map();
        players.forEach(player => this.playerStates.set(player, new PlayerState()));
        this.playerScores = new Map();
        players.forEach(player => this.playerScores.set(player, 0));
      }
      
      playersInGame() {
        return Array.from(this.playerStates.entries().filter(([player, state]) => {
          return !state.busted && !state.stayed && !state.frozen;
        }).map(([player, state]) => player));
      }
      
      winner() {
        const scorersAbove200 = [...this.playerScores.entries().filter(([player, score]) => score >= 200)];
        if (scorersAbove200.length === 0) {
          return null;
        } else {
          const max = Math.max(...scorersAbove200.map(([player, score]) => score));
          const topScorers = scorersAbove200.filter(([player, score]) => score === max).map(([player, score]) => player);
          if (topScorers.length === 1) {
            return topScorers[0];
          } else {
            return null;
          }
        }
      }
      
      static createDeck() {
        const deck = [];
        
        deck.push('0')
        for (let number = 1; number <= 12; ++number) {
          for (let quantity = 0; quantity < number; ++quantity) {
            deck.push(String(number));
          }
        }
        deck.push('x2');
        [2, 4, 6, 8, 10].forEach(bonus => deck.push('+' + String(bonus)));
        deck.push('Freeze');
        deck.push('Freeze');
        deck.push('Freeze');
        deck.push('Flip3');
        deck.push('Flip3');
        deck.push('Flip3');
        deck.push('SecondChance');
        deck.push('SecondChance');
        deck.push('SecondChance');

        return deck;
      }
      
      shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
      }
    }
    
    function createPlayers() {
      return [
        new RandomPlayer("Random 1"),
        new HitUpToN("Hit to 21", 21),
        new ExpectedValuePlayer("Expected Value"),
        new HumanApproximatedExpectedValuePlayer("Human Approximation")
      ];
    }
    
    function playGame() {
      const gameState = new GameState(createPlayers());
      
      function giveCards(player, count) {
        const playerState = gameState.playerStates.get(player);

        const drawnCards = [];

        let resolveCardsAfter = true;
        const cardsToResolveAfter = [];
        for (let i = 0; i < count; ++i) {
          if (gameState.deck.length === 0) {
            gameState.deck = gameState.discarded;
            gameState.discarded = [];
            gameState.shuffleDeck();
          }
          
          const flippedCard = gameState.deck.pop();
          drawnCards.push(flippedCard);

          if (flippedCard === 'Freeze') {
            cardsToResolveAfter.push(flippedCard);
            playerState.cards.push(flippedCard);
          } else if (flippedCard === 'Flip3') {
            cardsToResolveAfter.push(flippedCard);
            playerState.cards.push(flippedCard);
          } else if (flippedCard === 'SecondChance' && playerState.cards.some(playerCard => playerCard === 'SecondChance')) {
            const target = player.giveSecondChance(gameState);
            if (target !== null) {
              gameState.playerStates.get(target).cards.push('SecondChance');
            } else {
              gameState.discarded.push('SecondChance');
            }
          } else if (['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'].some(numberCard => numberCard === flippedCard)) {
            const duplicateExists = playerState.cards.some(playerCard => playerCard === flippedCard);
            if (duplicateExists) {
              if (playerState.cards.some(playerCard => playerCard === 'SecondChance')) {
                playerState.cards = playerState.cards.filter(playerCard => playerCard !== 'SecondChance');
                gameState.discarded.push('SecondChance');
                gameState.discarded.push(flippedCard);
              } else {
                playerState.busted = true;
                playerState.cards.push(flippedCard);
                resolveCardsAfter = false;
                break;
              }
            } else {
              playerState.cards.push(flippedCard);
              if (playerState.flippedSeven()) {
                break;
              }
            }
          } else {
            // Bonus or second chance.
            playerState.cards.push(flippedCard);
          }
        }
        
        if (resolveCardsAfter) {
          for (let i = 0; i < cardsToResolveAfter.length; ++i) {
            const flippedCard = cardsToResolveAfter[i];
            if (flippedCard === 'Freeze') {
              const target = player.freeze(gameState);
              gameState.playerStates.get(target).frozen = true;
              if (target.name === player.name) {
                break;
              }
            } else if (flippedCard === 'Flip3') {
              const target = player.flip3(gameState);
              giveCards(target, 3);
              if (gameState.playerStates.values().some(s => s.flippedSeven()) || playerState.frozen || playerState.busted) {
                break;
              }
            }
          }
        }
      }
      
      let startPlayerIndex = Math.floor(Math.random() * players.length);
      while (gameState.winner() === null) {
        gameState.playerStates.values().forEach(playerState => playerState.cards.forEach(c => gameState.discarded.push(c)));
        gameState.playerStates.values().forEach(playerState => playerState.reset());
        let currentPlayerIndex = startPlayerIndex;
        while (gameState.playersInGame().length > 0) {
          let [currentPlayer, currentPlayerState] = Array.from(gameState.playerStates.entries())[currentPlayerIndex];
          
          if (!currentPlayerState.frozen && !currentPlayerState.busted && !currentPlayerState.stayed) {
            if (currentPlayer.hit(gameState)) {
              giveCards(currentPlayer, 1);
            } else {
              gameState.playerStates.get(currentPlayer).stayed = true;
            }
          }
          
          currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        }
        gameState.playerStates.entries().forEach(([player, playerState]) => {
          gameState.playerScores.set(player, gameState.playerScores.get(player) + playerState.score());
        });
        startPlayerIndex = (startPlayerIndex + 1) % players.length;
      }
      return gameState.winner();
    }
    
    let gamesPlayedSoFar = 0;
    const totalGames = 5000;
    const players = createPlayers();
    const wins = players.map(() => 0);

    const ctx = document.getElementById('winChart');
    const chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: players.map(p => p.name),
        datasets: [{
          label: 'Win %',
          data: players.map(() => 0),
          backgroundColor: ['#3498db', '#2ecc71', '#e74c3c']
        }]
      },
      options: {
        plugins: {
          legend: { display: false }
        },
        animation: { duration: 0 },
        scales: {
          y: {
            beginAtZero: true,
            max: 100,
            title: { display: true, text: 'Percentage' }
          }
        }
      }
    });

    function updateChart(gamesPlayed) {
      chart.data.datasets[0].data = wins.map(winCount => (winCount / gamesPlayed * 100).toFixed(1));
      chart.update('none');
    }

    function simulateWins() {
      for (let i = 0; i < totalGames; i++) {
        setTimeout(() => {
          const winner = playGame()
          wins[players.findIndex(p => p.name === winner.name)]++;
          gamesPlayedSoFar++;
          updateChart(gamesPlayedSoFar);
        });
      }
    }

    simulateWins();
  </script>
</body>
</html>
